\section{Language-specific}

\subsection{C++}

\subsubsection{G++ builtins}

\begin{itemize}
\item  \_\_builtin\_popcount(x)~--- количество единичных бит в двоичном представлении 32-битного (знакового или беззнакового) целого числа.
\item \_\_builtin\_popcountll(x)~--- то же самое для 64-битных типов.
\item \_\_builtin\_ctz(x)~--- количество нулей на конце двоичного представления 32-битного целого числа. Например, для $5$ вернётся $0$, для $272 = 256 + 16$ --- $4$ и т. д. Может не работать для нуля (вообще не стоит вызывать для $x = 0$, по-моему это и упасть может).
\item \_\_builtin\_ctzll(x)~--- то же самое для 64-битных типов.
\item \_\_builtin\_clz(x)~--- количество нулей в начале двоичного представления 32-битного целого числа. Например, для $2^{31}$ или $-2^{31}$ вернётся
$0$, для $1$ --- $31$ и т. д. Тоже не надо вызвывать с $x = 0$.
\item \_\_builtin\_clzll(x)~--- то же самое для 64-битных типов.

\item bitset<N>.\_Find\_first()~--- номер первой позиции с единицей в битсете или его размер
(то есть $N$), если на всех позициях нули.
\item bitset<N>.\_Find\_next(x)~--- номер первой позиции с единицей среди позиций с номерами строго больше $x$; если такой нет, то $N$.
\end{itemize}

\subsubsection{hash}

\lstinputlisting[language=C++]{code/hacks.cpp}

\subsection{Python}

\lstinputlisting[language=Python]{code/python.py}
